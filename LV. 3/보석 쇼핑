// 보석 쇼핑
// 투포인터 알고리즘 이용
  // left, right 모두 0에서 시작
  // 모든 보석을 구매하지 못할 경우 right를 한 칸씩 늘리며 구입, 모든 보석을 구매할 경우 left를 한 칸씩 이동하며 한 개씩 빼며 최소 길이를 찾아감
  // 모든 보석을 구매할 수 있을 때는 시작(left)와 끝(right)를 저장하며, 길이 역시 저장하여 최소 길이 탐색

#include <string>
#include <vector>
#include <map>

using namespace std;

vector<int> solution(vector<string> gems) {
    vector<int> answer(2, 0);
    
    map<string, int> m; // 보석의 종류가 몇 개인지 알기 위해
    map<string, int> ans; // 현재까지 구매한 보석의 종류 및 개수를 알기 위해
    
    int a_size = 100001; // 최댓값으로 대입, 정답의 길이
    
    for(int i = 0 ; i < gems.size() ; i++)
    {
        if(m.find(gems[i]) == m.end() || m.size() == 0)
            m[gems[i]] = 1;
        else
            m[gems[i]]++;
    }
    
    int left = 0, right = 0;
    int temp = 0;
    
    while(1)
    {
        // 현재 구매한 보석의 종류가 적을 경우
        if(ans.size() < m.size())
        {
            // right에 해당하는 보석 구매 후 right를 이동
              // 이전에 구매했던 보석이면 map의 find를 이용해 해당 보석의 value에 +1
            if(ans.find(gems[right]) == ans.end())
                ans[gems[right]] = 1;
            else
                ans[gems[right]]++;
            right++;
        }
        
        // 모든 보석의 종류를 구입했으면, left를 이동하여 최소 길이 탐색
            // left에 해당하는 보석 value를 -1, 만약 0이 되면 해당 보석은 구매하지 못한 것이므로 map에서 삭제
        else if(ans.size() == m.size())
        {
            ans[gems[left]]--;
            if(ans[gems[left]] == 0)
                ans.erase(gems[left]);
            left++;
        }
        
        // right가 맨 마지막에 도달했을 때,
          // 모든 종류의 보석을 살 수 있으면 left를 이동시키며 최소 길이가 되는 부분을 찾아야함
          // 하지만, 모든 종류의 보석을 구매하지 못하면 모든 탐색은 끝난 것이므로 종료 
        if(right == gems.size())
        {
            if(ans.size() < m.size())
                break;          
        }
        
        // 모든 종류의 보석을 구매할 수 있으면, 길이 비교 후 이 전보다 짧으면, 시작(left)와 끝(right)지점 저장 및 길이 갱신
        if(ans.size() == m.size())
        {
            temp = abs(right - left);
            if(a_size > temp)
            {
                a_size = temp;
                answer[0] = left + 1;
                answer[1] = right;
            }
        }        
    }
    
    return answer;
}
